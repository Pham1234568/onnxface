<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Face Detection</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      color: white;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 2.5em;
      margin: 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 1fr 350px;
      gap: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }

    .video-section {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .video-container {
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      background: #000;
    }

    video, canvas {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 10px;
    }

    #liveCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .section-label {
      text-align: center;
      margin-top: 15px;
      font-weight: 600;
      font-size: 1.1em;
    }

    .controls-panel {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      height: fit-content;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .control-group {
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .control-group:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .control-group h3 {
      margin: 0 0 15px 0;
      font-size: 1.1em;
      opacity: 0.9;
    }

    .btn {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      border: none;
      border-radius: 8px;
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .btn:disabled {
      background: rgba(255, 255, 255, 0.2);
      cursor: not-allowed;
      opacity: 0.6;
    }

    .btn-danger {
      background: linear-gradient(45deg, #f44336, #d32f2f) !important;
    }

    .btn-warning {
      background: linear-gradient(45deg, #ff9800, #f57c00) !important;
    }

    .loading-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid transparent;
      border-top: 2px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .status-display {
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.4;
      min-height: 20px;
    }

    .status-success { color: #4CAF50; }
    .status-error { color: #f44336; }
    .status-warning { color: #ff9800; }
    .status-info { color: #2196F3; }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      margin-top: 10px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #8BC34A);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-top: 15px;
    }

    .stat-item {
      background: rgba(0, 0, 0, 0.2);
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-value {
      font-size: 1.8em;
      font-weight: bold;
      margin-bottom: 5px;
      color: #4CAF50;
    }

    .stat-label {
      font-size: 0.85em;
      opacity: 0.8;
    }

    .settings-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .setting-item {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .setting-item label {
      font-size: 13px;
      opacity: 0.9;
      font-weight: 500;
    }

    .setting-input {
      padding: 8px 10px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 14px;
      width: 80px;
    }

    .setting-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .best-face-preview {
      width: 100%;
      max-width: 200px;
      height: auto;
      border-radius: 8px;
      border: 2px solid #4CAF50;
      background: #000;
    }

    .server-result {
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 8px;
      font-size: 12px;
      font-family: monospace;
      max-height: 150px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .debug-panel {
      background: rgba(0, 0, 0, 0.4);
      padding: 10px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-line;
      line-height: 1.3;
    }

    @media (max-width: 1200px) {
      .container {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .controls-panel {
        order: -1;
      }
    }

    @media (max-width: 768px) {
      body { padding: 10px; }
      .header h1 { font-size: 2em; }
      .btn { padding: 10px; font-size: 13px; }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Face Detection</h1>
  </div>
  
  <div class="container">
    <div class="video-section">
      <div class="video-container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="liveCanvas"></canvas>
      </div>
      <div class="section-label">üìπ Live Detection</div>
    </div>
    
    <div class="video-section">
      <div class="video-container">
        <canvas id="resultsCanvas"></canvas>
      </div>
      <div class="section-label">üîç Detection Results</div>
    </div>
    
    <!-- Controls Panel -->
    <div class="controls-panel">
      <!-- Main Controls -->
      <div class="control-group">
        <h3>üìã Controls</h3>
        <button id="captureBtn" class="btn">Start Capturing Best Face</button>
        <button id="downloadBtn" class="btn" disabled>Download Best Face</button>
        <button id="resetBtn" class="btn">Reset Session</button>
        <button id="s2sBtn" class="btn" disabled>Send to Server</button>
      </div>
      
      <!-- Status Display -->
      <div class="control-group">
        <h3>üìä Status</h3>
        <div id="statusDisplay" class="status-display">
          <div>Ready to start...</div>
        </div>
        <div class="progress-bar">
          <div id="progressFill" class="progress-fill"></div>
        </div>
      </div>
      
      <!-- Settings -->
      <div class="control-group">
        <h3>‚öôÔ∏è Settings</h3>
        <div class="settings-group">
          <div class="setting-item">
            <label>Detection Threshold:</label>
            <input id="thresholdInput" type="number" class="setting-input" min="0.1" max="0.9" step="0.1" value="0.5">
          </div>
          <div class="setting-item">
            <label>Blur Threshold:</label>
            <input id="blurInput" type="number" class="setting-input" min="10" max="200" step="10" value="50">
          </div>
          <div class="setting-item">
            <label>Server URL:</label>
            <input id="serverInput" type="text" class="setting-input" style="width: 120px;" value="https://agegender.onrender.com/predict">
          </div>
        </div>
      </div>
      
      <!-- Best Face Preview -->
      <div class="control-group">
        <h3>üèÜ Best Face</h3>
        <canvas id="bestFaceCanvas" class="best-face-preview" style="display: none;"></canvas>
        <div id="bestFaceInfo" style="font-size: 11px; color: #ccc; margin-top: 5px;"></div>
      </div>
      
      <!-- Server Response -->
      <div class="control-group">
        <h3>üåê Server Response</h3>
        <div id="serverResult" class="server-result">No server response yet...</div>
      </div>
      
      <!-- Debug Info -->
      <div class="control-group">
        <h3>üêõ Debug</h3>
        <div id="debugPanel" class="debug-panel">Debug info will appear here...</div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as ort from "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/esm/ort.min.js";
    import {nms, distance2kps, distance2bbox, alignFace, calculateFaceQuality, varianceOfLaplacian} from './evaluate.js';
    
    ort.env.wasm.proxy = false;
    ort.env.wasm.numThreads = 3;
    ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/";

    class AppState {
      constructor() {
        this.isCapturing = false;
        this.isSending = false;
        this.bestScore = 0;
        this.bestFaceData = null;
        this.bestFaceInfo = null;
        this.facesDetected = 0;
        this.facesProcessed = 0;
        this.currentQuality = 0;
        this.detectionThreshold = 0.5;
        this.blurThreshold = 50;
        this.serverUrl = 'https://agegender.onrender.com/predict';
        this.isProcessing = false;
        this.lastDetectionTime = 0;
        this.debugMessages = [];
      }

      reset() {
        this.isCapturing = false;
        this.isSending = false;
        this.bestScore = 0;
        this.bestFaceData = null;
        this.bestFaceInfo = null;
        this.facesDetected = 0;
        this.facesProcessed = 0;
        this.currentQuality = 0;
        this.isProcessing = false;
        this.debugMessages = [];
      }

      addDebugMessage(message) {
        const timestamp = new Date().toLocaleTimeString();
        this.debugMessages.unshift(`[${timestamp}] ${message}`);
        if (this.debugMessages.length > 50) {
          this.debugMessages.pop();
        }
      }
    }

    class UIController {
      constructor() {
        this.elements = {
          captureBtn: document.getElementById('captureBtn'),
          downloadBtn: document.getElementById('downloadBtn'),
          resetBtn: document.getElementById('resetBtn'),
          s2sBtn: document.getElementById('s2sBtn'),
          statusDisplay: document.getElementById('statusDisplay'),
          progressFill: document.getElementById('progressFill'),
          bestScoreStat: document.getElementById('bestScoreStat'),
          detectedStat: document.getElementById('detectedStat'),
          processedStat: document.getElementById('processedStat'),
          qualityStat: document.getElementById('qualityStat'),
          thresholdInput: document.getElementById('thresholdInput'),
          blurInput: document.getElementById('blurInput'),
          serverInput: document.getElementById('serverInput'),
          bestFaceCanvas: document.getElementById('bestFaceCanvas'),
          bestFaceInfo: document.getElementById('bestFaceInfo'),
          serverResult: document.getElementById('serverResult'),
          debugPanel: document.getElementById('debugPanel')
        };
      }

      updateStatus(message, type = 'info') {
        const statusClasses = {
          success: 'status-success',
          error: 'status-error',
          warning: 'status-warning',
          info: 'status-info'
        };
        
        this.elements.statusDisplay.innerHTML = `<div class="${statusClasses[type] || 'status-info'}">${message}</div>`;
      }

      updateProgress(percentage) {
        this.elements.progressFill.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
      }

      updateBestFace(canvas, info) {
        if (canvas) {
          this.elements.bestFaceCanvas.width = canvas.width;
          this.elements.bestFaceCanvas.height = canvas.height;
          const ctx = this.elements.bestFaceCanvas.getContext('2d');
          ctx.drawImage(canvas, 0, 0);
          this.elements.bestFaceCanvas.style.display = 'block';
          this.elements.downloadBtn.disabled = false;
          
          if (info) {
            this.elements.bestFaceInfo.textContent = `${info.width}√ó${info.height} | Blur: ${info.blur} | Quality: ${info.quality}`;
          }
        } else {
          this.elements.bestFaceCanvas.style.display = 'none';
          this.elements.downloadBtn.disabled = true;
          this.elements.bestFaceInfo.textContent = '';
        }
      }

      updateDebug(messages) {
        this.elements.debugPanel.textContent = messages.slice(0, 20).join('\n');
      }

      updateServerResponse(response) {
        this.elements.serverResult.textContent = response || 'No server response yet...';
      }

      setButtonState(button, text, disabled = false, loading = false) {
        button.disabled = disabled;
        if (loading) {
          button.innerHTML = `<span class="loading-spinner"></span>${text}`;
        } else {
          button.textContent = text;
        }
      }
      
      // Updated method to handle button states properly
      updateButtonStates(state) {
        // Capture button
        if (state.isCapturing) {
          this.setButtonState(this.elements.captureBtn, 'Stop Capturing', false, false);
          this.elements.captureBtn.classList.add('btn-danger');
        } else {
          this.setButtonState(this.elements.captureBtn, 'Start Capturing Best Face', false, false);
          this.elements.captureBtn.classList.remove('btn-danger');
        }

        // Send to Server button - only enabled when not capturing and has best face data and not currently sending
        this.elements.s2sBtn.disabled = state.isCapturing || !state.bestFaceData || state.isSending;
        if (state.isSending) {
          this.setButtonState(this.elements.s2sBtn, 'Sending...', true, true);
        } else {
          this.setButtonState(this.elements.s2sBtn, 'Send to Server', this.elements.s2sBtn.disabled, false);
        }

        // Download button - enabled when has best face data
        this.elements.downloadBtn.disabled = !state.bestFaceData;

        // Reset button - always enabled unless sending
        this.elements.resetBtn.disabled = state.isSending;
      }
    }

    class EnhancedFaceDetector {
      constructor(session) {
        this.session = session;
        this.nmsThresh = 0.4;
        this.centerCache = new Map();
        this.initializeDetector();
      }

      initializeDetector() {
        const outputs = this.session.outputNames;
        const F = outputs.length;
        
        if (F === 6 || F === 9) {
          this.fmc = 3;
          this.strides = [8, 16, 32];
          this.useKps = F === 9;
          this.numAnchors = 2;
        } else {
          this.fmc = 5;
          this.strides = [8, 16, 32, 64, 128];
          this.useKps = F === 15;
          this.numAnchors = 1;
        }
        
        this.inputName = this.session.inputNames[0];
        this.outputNames = this.session.outputNames;
        this.inputSize = [640, 640];
      }

      static async create(modelUrl) {
        try {
          const session = await ort.InferenceSession.create(modelUrl, {
            executionProviders: ['wasm'],
          });
          return new EnhancedFaceDetector(session);
        } catch (error) {
          console.error("Failed to create face detector:", error);
          throw new Error(`Model loading failed: ${error.message}`);
        }
      }

      async detect(source, threshold = 0.5) {
        if (!source || source.videoWidth === 0 || source.videoHeight === 0) {
          return [];
        }

        try {
          const startTime = performance.now();
          const faces = await this.performDetection(source, threshold);
          const endTime = performance.now();
          
          // Add performance info to faces
          faces.forEach(face => {
            face.detectionTime = endTime - startTime;
          });
          
          return faces;
        } catch (error) {
          console.error("Detection error:", error);
          return [];
        }
      }

      async performDetection(source, threshold) {
        const imgHeight = source.videoHeight;
        const imgWidth = source.videoWidth;
        const [inputWidth, inputHeight] = this.inputSize;
        
        const imRatio = imgHeight / imgWidth;
        const modelRatio = inputHeight / inputWidth;
        
        let newHeight, newWidth, detScale;
        if (imRatio > modelRatio) {
          newHeight = inputHeight;
          newWidth = Math.round(newHeight / imRatio);
        } else {
          newWidth = inputWidth;
          newHeight = Math.round(newWidth * imRatio);
        }
        detScale = newHeight / imgHeight;

        // Prepare input tensor
        const tensor = this.prepareInputTensor(source, inputWidth, inputHeight, newWidth, newHeight);
        
        // Run inference
        const outputs = await this.session.run({ [this.inputName]: tensor });
        
        // Process outputs
        return this.processOutputs(outputs, detScale, threshold, inputHeight, inputWidth);
      }

      prepareInputTensor(source, inputWidth, inputHeight, newWidth, newHeight) {
        const detCanvas = document.createElement('canvas');
        detCanvas.width = inputWidth;
        detCanvas.height = inputHeight;
        const detCtx = detCanvas.getContext('2d');
        
        detCtx.fillStyle = 'black';
        detCtx.fillRect(0, 0, inputWidth, inputHeight);
        detCtx.drawImage(source, 0, 0, newWidth, newHeight);

        const imageData = detCtx.getImageData(0, 0, inputWidth, inputHeight);
        const data = imageData.data;
        const floatData = new Float32Array(inputWidth * inputHeight * 3);

        for (let y = 0; y < inputHeight; y++) {
          for (let x = 0; x < inputWidth; x++) {
            const idx = (y * inputWidth + x) * 4;
            const outIdx = y * inputWidth + x;
            
            floatData[outIdx] = (data[idx + 2] - 127.5) / 128; // B
            floatData[outIdx + inputWidth * inputHeight] = (data[idx + 1] - 127.5) / 128; // G
            floatData[outIdx + inputWidth * inputHeight * 2] = (data[idx] - 127.5) / 128; // R
          }
        }

        return new ort.Tensor('float32', floatData, [1, 3, inputHeight, inputWidth]);
      }

      processOutputs(outputs, detScale, threshold, inputHeight, inputWidth) {
        const scoresList = [];
        const bboxesList = [];
        const kpsList = [];

        for (let idx = 0; idx < this.strides.length; idx++) {
          const stride = this.strides[idx];
          const scores = outputs[this.outputNames[idx]].data;
          const bboxPred = outputs[this.outputNames[idx + this.fmc]].data;
          const kpsPred = this.useKps ? outputs[this.outputNames[idx + 2 * this.fmc]].data : null;

          const scaledBboxPred = Array.from(bboxPred).map(x => x * stride);
          const scaledKpsPred = kpsPred ? Array.from(kpsPred).map(x => x * stride) : null;

          const height = Math.floor(inputHeight / stride);
          const width = Math.floor(inputWidth / stride);
          const key = `${height}-${width}-${stride}`;
          
          let anchorCenters = this.centerCache.get(key);
          if (!anchorCenters) {
            const centers = [];
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                centers.push([x * stride, y * stride]);
              }
            }
            
            anchorCenters = this.numAnchors > 1 
              ? centers.flatMap(c => Array(this.numAnchors).fill(c))
              : centers;
            
            this.centerCache.set(key, anchorCenters);
          }

          const posIndices = [];
          for (let i = 0; i < scores.length; i++) {
            if (scores[i] >= threshold) {
              posIndices.push(i);
            }
          }

          if (posIndices.length > 0) {
            const bboxes = distance2bbox(anchorCenters, scaledBboxPred, [inputHeight, inputWidth]);
            const posScores = posIndices.map(i => scores[i]);
            const posBboxes = posIndices.map(i => bboxes[i]);
            
            scoresList.push(posScores);
            bboxesList.push(posBboxes);
            
            if (this.useKps && scaledKpsPred) {
              const kpss = distance2kps(anchorCenters, scaledKpsPred, [inputHeight, inputWidth]);
              const posKpss = posIndices.map(i => kpss[i]);
              kpsList.push(posKpss);
            }
          }
        }

        const allScores = scoresList.flat();
        const allBboxes = bboxesList.flat();
        const allKpss = this.useKps ? kpsList.flat() : [];

        if (allScores.length === 0) {
          return [];
        }

        const dets = allBboxes.map((bbox, i) => [...bbox, allScores[i]]);
        const keepIndices = nms(dets, this.nmsThresh);

        return keepIndices.map(i => {
          const det = dets[i];
          return {
            bbox: [
              det[0] / detScale,
              det[1] / detScale,
              (det[2] - det[0]) / detScale,
              (det[3] - det[1]) / detScale
            ],
            score: det[4],
            kps: this.useKps && allKpss[i] ? allKpss[i].map(([kx, ky]) => [
              kx / detScale,
              ky / detScale
            ]) : []
          };
        });
      }
    }

    class ServerHandler {
      static async sendBestFace(faceDataUrl, metadata, serverUrl, debugCallback) {
        try {
          debugCallback?.("Preparing server request...");
          
          if (!faceDataUrl || !faceDataUrl.startsWith('data:image/')) {
            throw new Error('Invalid face data URL');
          }
          
          const response = await fetch(faceDataUrl);
          const blob = await response.blob();
          
          if (blob.size === 0) {
            throw new Error('Empty image blob');
          }
          
          if (blob.size > 10 * 1024 * 1024) {
            throw new Error('Image too large (>10MB)');
          }
          
          const formData = new FormData();
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const filename = `best_face_${timestamp}.png`;
          
          formData.append('image', blob, filename);
          formData.append('score', metadata.score.toString());
          formData.append('timestamp', timestamp);
          formData.append('processed_faces', metadata.processedCount.toString());
          formData.append('blur_score', metadata.blurScore?.toString() || '0');
          formData.append('quality_score', metadata.qualityScore?.toString() || '0');
          
          debugCallback?.(`Sending ${filename} to server...`);
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 30000);
          
          const serverResponse = await fetch(serverUrl, {
            method: 'POST',
            body: formData,
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if (serverResponse.ok) {
            const result = await serverResponse.text();
            debugCallback?.("Server response received successfully");
            return { success: true, response: result };
          } else {
            const errorText = await serverResponse.text().catch(() => 'Unknown error');
            throw new Error(`Server error ${serverResponse.status}: ${errorText}`);
          }
          
        } catch (error) {
          const errorMessage = error.name === 'AbortError' 
            ? 'Request timeout (30s)' 
            : error.message;
          debugCallback?.(`Server error: ${errorMessage}`);
          return { success: false, error: errorMessage };
        }
      }
    }

    class FaceQualityAnalyzer {
      static analyzeFace(alignedCanvas, keypoints, originalBbox) {
        if (!alignedCanvas || !keypoints || keypoints.length < 5) {
          return null;
        }
        
        const ctx = alignedCanvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, alignedCanvas.width, alignedCanvas.height);
        
        const blurScore = varianceOfLaplacian(imageData, alignedCanvas.width, alignedCanvas.height);

        const qualityScore = calculateFaceQuality(keypoints);

        const faceArea = originalBbox[2] * originalBbox[3];
        const imageArea = alignedCanvas.width * alignedCanvas.height;
        const sizeRatio = faceArea / imageArea;
        
        return {
          blur: blurScore,
          quality: qualityScore,
          size: sizeRatio,
          width: alignedCanvas.width,
          height: alignedCanvas.height,
          overallScore: qualityScore
        };
      }
    }

    class FaceDetectionApp {
      constructor() {
        this.state = new AppState();
        this.ui = new UIController();
        this.detector = null;
        this.video = null;
        this.canvases = {};
        this.animationFrameId = null;
        
        this.initializeElements();
        this.setupEventListeners();
        this.initialize();
      }

      initializeElements() {
        this.video = document.getElementById('video');
        this.canvases = {
          live: document.getElementById('liveCanvas'),
          results: document.getElementById('resultsCanvas'),
          bestFace: document.getElementById('bestFaceCanvas')
        };
        
        // Get canvas contexts
        this.contexts = {
          live: this.canvases.live.getContext('2d'),
          results: this.canvases.results.getContext('2d'),
          bestFace: this.canvases.bestFace.getContext('2d')
        };
      }

      setupEventListeners() {
        // Main control buttons
        this.ui.elements.captureBtn.addEventListener('click', () => this.handleCaptureToggle());
        this.ui.elements.downloadBtn.addEventListener('click', () => this.handleDownload());
        this.ui.elements.resetBtn.addEventListener('click', () => this.handleReset());
        this.ui.elements.s2sBtn.addEventListener('click', () => this.handleSend2Server());
        
        // Settings inputs
        this.ui.elements.thresholdInput.addEventListener('change', (e) => {
          this.state.detectionThreshold = parseFloat(e.target.value);
          this.state.addDebugMessage(`Detection threshold: ${this.state.detectionThreshold}`);
        });
        
        this.ui.elements.blurInput.addEventListener('change', (e) => {
          this.state.blurThreshold = parseFloat(e.target.value);
          this.state.addDebugMessage(`Blur threshold: ${this.state.blurThreshold}`);
        });
        
        this.ui.elements.serverInput.addEventListener('change', (e) => {
          this.state.serverUrl = e.target.value.trim();
          this.state.addDebugMessage(`Server URL: ${this.state.serverUrl}`);
        });

        // Handle video errors
        this.video.addEventListener('error', (e) => {
          this.state.addDebugMessage(`Video error: ${e.message}`);
          this.ui.updateStatus('Video stream error', 'error');
        });
      }

      async initialize() {
        try {
          this.ui.updateStatus('Initializing application...', 'info');
          
          // Initialize detector
          await this.initializeDetector();
          
          // Initialize camera
          await this.initializeCamera();
          
          // Start rendering loop
          this.startRenderLoop();
          
          this.ui.updateStatus('Ready to start detection', 'success');
          this.state.addDebugMessage('Application initialized successfully');
          
        } catch (error) {
          console.error('Initialization failed:', error);
          this.state.addDebugMessage(`Initialization failed: ${error.message}`);
          this.ui.updateStatus(`Initialization failed: ${error.message}`, 'error');
        }
      }

      async initializeDetector() {
        try {
          this.state.addDebugMessage('Loading face detection model...');
          this.detector = await EnhancedFaceDetector.create('model_1_kps.onnx');
          this.state.addDebugMessage('Model loaded successfully');
        } catch (error) {
          this.state.addDebugMessage(`Model loading failed: ${error.message}`);
          
          // Fallback to demo detector for development
          this.detector = {
            detect: async (source, threshold) => {
              // Simulate realistic detection results
              if (Math.random() > 0.7) {
                const mockFace = {
                  bbox: [
                    100 + Math.random() * 200,
                    100 + Math.random() * 150,
                    120 + Math.random() * 80,
                    150 + Math.random() * 100
                  ],
                  score: 0.7 + Math.random() * 0.3,
                  kps: [
                    [140 + Math.random() * 20, 130 + Math.random() * 10],
                    [190 + Math.random() * 20, 130 + Math.random() * 10],
                    [165 + Math.random() * 10, 150 + Math.random() * 10],
                    [155 + Math.random() * 15, 180 + Math.random() * 10],
                    [175 + Math.random() * 15, 180 + Math.random() * 10]
                  ],
                  detectionTime: 20 + Math.random() * 30
                };
                return [mockFace];
              }
              return [];
            }
          };
          this.state.addDebugMessage('Using demo detector (model unavailable)');
        }
      }

      async initializeCamera() {
        try {
          this.state.addDebugMessage('Requesting camera access...');
          
          const constraints = {
            video: {
              width: { ideal: 640, max: 1280 },
              height: { ideal: 480, max: 720 },
              frameRate: { ideal: 30, max: 60 },
              facingMode: 'user'
            }
          };
          
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          this.video.srcObject = stream;
          
          return new Promise((resolve, reject) => {
            this.video.onloadedmetadata = () => {
              this.video.play()
                .then(() => {
                  this.setupCanvases();
                  this.state.addDebugMessage(`Camera initialized: ${this.video.videoWidth}x${this.video.videoHeight}`);
                  resolve();
                })
                .catch(reject);
            };
            
            this.video.onerror = reject;
            
            // Timeout after 10 seconds
            setTimeout(() => reject(new Error('Camera initialization timeout')), 10000);
          });
          
        } catch (error) {
          throw new Error(`Camera access failed: ${error.message}`);
        }
      }

      setupCanvases() {
        const width = this.video.videoWidth;
        const height = this.video.videoHeight;
        
        Object.values(this.canvases).forEach(canvas => {
          if (canvas !== this.canvases.bestFace) {
            canvas.width = width;
            canvas.height = height;
          }
        });
        
        this.state.addDebugMessage(`Canvas setup: ${width}x${height}`);
      }

      startRenderLoop() {
        const render = async () => {
          try {
            if (this.video.readyState === 4 && this.video.videoWidth > 0) {
              await this.processFrame();
            }
            this.animationFrameId = requestAnimationFrame(render);
          } catch (error) {
            console.error('Render loop error:', error);
            this.state.addDebugMessage(`Render error: ${error.message}`);
          }
        };
        
        render();
      }

      async processFrame() {
        const startTime = performance.now();
        
        // Draw live video feed
        this.contexts.live.drawImage(this.video, 0, 0);
        this.contexts.results.drawImage(this.video, 0, 0);
        
        // Skip detection if processing or too frequent
        const timeSinceLastDetection = startTime - this.state.lastDetectionTime;
        if (this.state.isProcessing || timeSinceLastDetection < 100) { 
          return;
        }
        
        this.state.isProcessing = true;
        this.state.lastDetectionTime = startTime;
        
        try {
          const faces = await this.detector.detect(this.video, this.state.detectionThreshold);
          
          // Update detection count
          if (faces.length > 0) {
            this.state.facesDetected++;
          }
          
          // Process detected faces
          await this.processFaces(faces);
          
          // Draw detection results
          this.drawDetectionResults(faces);
          
          // Update UI
          this.updateUI();
          
        } catch (error) {
          this.state.addDebugMessage(`Detection error: ${error.message}`);
        } finally {
          this.state.isProcessing = false;
        }
        
        const processingTime = 1000 /(performance.now() - startTime);
        if (processingTime > 50) { // Log slow frames
          this.state.addDebugMessage(`Slow frame: ${processingTime.toFixed(1)}fps`);
        }
      }

      async processFaces(faces) {
        if (!this.state.isCapturing || faces.length === 0) {
          return;
        }
        
        for (const face of faces) {
          if (face.kps.length >= 5) {
            await this.processSingleFace(face);
          }
        }
      }

      async processSingleFace(face) {
        try {
          this.state.facesProcessed++;
          const sourceCanvas = document.createElement('canvas');
          sourceCanvas.width = this.video.videoWidth;
          sourceCanvas.height = this.video.videoHeight;
          const sourceCtx = sourceCanvas.getContext('2d');
          sourceCtx.drawImage(this.video, 0, 0);
          
          // Align face
          const faceBBox = {
            x1: face.bbox[0],
            y1: face.bbox[1],
            x2: face.bbox[0] + face.bbox[2],
            y2: face.bbox[1] + face.bbox[3]
          };
          
          const alignedCanvas = alignFace(sourceCanvas, face.kps, faceBBox);
          if (!alignedCanvas) {
            this.state.addDebugMessage('Face alignment failed');
            return;
          }
          
          // Analyze face quality
          const analysis = FaceQualityAnalyzer.analyzeFace(alignedCanvas, face.kps, face.bbox);
          if (!analysis) {
            this.state.addDebugMessage('Face quality analysis failed');
            return;
          }
          
          this.state.currentQuality = analysis.blur;
        
          if (analysis.blur >= this.state.blurThreshold && analysis.overallScore > this.state.bestScore) {
            this.updateBestFace(alignedCanvas, analysis, face);
            this.state.addDebugMessage(`New best face! Score: ${analysis.overallScore.toFixed(3)}`);
          } else if (analysis.blur < this.state.blurThreshold) {
            this.state.addDebugMessage(`Face too blurry: ${analysis.blur.toFixed(1)} < ${this.state.blurThreshold}`);
          }
          
        } catch (error) {
          this.state.addDebugMessage(`Face processing error: ${error.message}`);
        }
      }

      updateBestFace(canvas, analysis, face) {
        this.state.bestScore = analysis.overallScore;
        this.state.bestFaceData = canvas.toDataURL('image/png');
        this.state.bestFaceInfo = {
          width: analysis.width,
          height: analysis.height,
          blur: analysis.blur.toFixed(1),
          quality: analysis.quality.toFixed(2),
          score: face.score,
          overallScore: analysis.overallScore
        };
        
        this.ui.updateBestFace(canvas, this.state.bestFaceInfo);
        this.ui.updateStatus('‚úì New best face captured!', 'success');
      }

      drawDetectionResults(faces) {
        const ctx = this.contexts.results;

        ctx.lineWidth = 2;
        ctx.strokeStyle = '#4CAF50';
        ctx.fillStyle = '#ff4444';
        ctx.font = '14px Arial';
        
        faces.forEach(face => {
          const [x, y, w, h] = face.bbox;
          
          // Draw bounding box
          ctx.strokeRect(x, y, w, h);
          
          // Draw confidence score
          ctx.fillStyle = '#4CAF50';
          ctx.fillRect(x, y - 25, 60, 20);
          ctx.fillStyle = 'white';
          ctx.fillText(`${(face.score * 100).toFixed(0)}%`, x + 5, y - 10);
          
          // Draw keypoints
          if (face.kps && face.kps.length >= 5) {
            ctx.fillStyle = '#ff4444';
            face.kps.forEach(([kx, ky], i) => {
              ctx.beginPath();
              ctx.arc(kx, ky, 3, 0, 2 * Math.PI);
              ctx.fill();
              
              // Label keypoints for debugging
              if (i < 5) {
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.fillText(i.toString(), kx + 5, ky - 5);
                ctx.fillStyle = '#ff4444';
                ctx.font = '14px Arial';
              }
            });
          }
        });
      }

      updateUI() {
        this.ui.updateDebug(this.state.debugMessages);
        
        // Update progress based on faces processed
        const progress = this.state.isCapturing 
          ? Math.min(100, (this.state.facesProcessed / 50) * 100) 
          : 0;
        this.ui.updateProgress(progress);
        
        // Update button states
        this.ui.updateButtonStates(this.state);
      }

      async handleCaptureToggle() {
        if (!this.state.isCapturing) {
          // Start capturing
          this.state.reset();
          this.state.isCapturing = true;
          
          this.ui.updateStatus('Capturing best face...', 'info');
          this.ui.updateBestFace(null); // Clear previous best face
          this.ui.updateServerResponse(''); // Clear previous server response
          
          this.state.addDebugMessage('Started capturing session');
          
        } else {
          // Stop capturing
          this.state.isCapturing = false;
          
          if (this.state.bestFaceData) {
            this.ui.updateStatus('‚úì Capturing stopped - Best face ready', 'success');
            this.state.addDebugMessage('Capturing session ended - best face available');
          } else {
            this.ui.updateStatus('‚ö† Capturing stopped - No best face captured', 'warning');
            this.state.addDebugMessage('Capturing session ended - no best face found');
          }
        }
      }

      async handleSend2Server() {
        if (this.state.isSending || !this.state.bestFaceData) {
          return;
        }

        try {
          this.state.isSending = true;
          this.ui.updateStatus('Sending best face to server...', 'info');
          
          const metadata = {
            score: this.state.bestScore,
            processedCount: this.state.facesProcessed,
            blurScore: this.state.bestFaceInfo?.blur,
            qualityScore: this.state.bestFaceInfo?.quality
          };
          
          const result = await ServerHandler.sendBestFace(
            this.state.bestFaceData,
            metadata,
            this.state.serverUrl,
            (msg) => this.state.addDebugMessage(msg)
          );
          
          if (result.success) {
            this.ui.updateStatus('‚úÖ Best face sent successfully!', 'success');
            this.ui.updateServerResponse(result.response);
            this.state.addDebugMessage('Server request completed successfully');
          } else {
            this.ui.updateStatus(`‚ùå Failed to send: ${result.error}`, 'error');
            this.ui.updateServerResponse(`Error: ${result.error}`);
            this.state.addDebugMessage(`Server request failed: ${result.error}`);
          }
          
        } catch (error) {
          this.state.addDebugMessage(`Unexpected server error: ${error.message}`);
          this.ui.updateStatus(`‚ùå Unexpected error: ${error.message}`, 'error');
        } finally {
          this.state.isSending = false;
        }
      }

      handleDownload() {
        if (!this.state.bestFaceData) {
          this.ui.updateStatus('No best face to download', 'warning');
          return;
        }
        
        try {
          const link = document.createElement('a');
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          link.download = `best_face_${timestamp}_score_${this.state.bestScore.toFixed(2)}.png`;
          link.href = this.state.bestFaceData;
          
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          this.ui.updateStatus('‚úÖ Best face downloaded successfully!', 'success');
          this.state.addDebugMessage('Best face downloaded');
          
        } catch (error) {
          this.state.addDebugMessage(`Download error: ${error.message}`);
          this.ui.updateStatus(`Download failed: ${error.message}`, 'error');
        }
      }

      handleReset() {
        if (this.state.isSending) {
          return; // Don't reset while sending
        }

        // Stop animation frame
        if (this.animationFrameId) {
          cancelAnimationFrame(this.animationFrameId);
        }
        
        // Reset state completely
        this.state.reset();
        
        // Clear UI completely
        this.ui.updateStatus('Reset complete - Ready to start', 'success');
        this.ui.updateProgress(0);
        this.ui.updateBestFace(null); // This will hide the canvas and disable download
        this.ui.updateServerResponse('No server response yet...'); // Clear server response
        this.ui.updateDebug([]); // Clear debug messages
        
        // Restart render loop
        this.startRenderLoop();
        
        this.state.addDebugMessage('Application reset completed');
      }

      // Cleanup method
      destroy() {
        if (this.animationFrameId) {
          cancelAnimationFrame(this.animationFrameId);
        }
        
        if (this.video.srcObject) {
          const stream = this.video.srcObject;
          const tracks = stream.getTracks();
          tracks.forEach(track => track.stop());
        }
        
        this.state.addDebugMessage('Application destroyed');
      }
    }

    // Initialize application when DOM is loaded
    let app;
    window.addEventListener('DOMContentLoaded', () => {
      app = new FaceDetectionApp();
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (app) {
        app.destroy();
      }
    });

    // Export for debugging
    window.FaceDetectionApp = { app, AppState, UIController, EnhancedFaceDetector, ServerHandler, FaceQualityAnalyzer };
  </script>
</body>
</html>
